#      prior = prior.func,
#      theta.range = theta.range)
}
data_model * h1_model
data_model@func()
h1_model
h1_model@theta_range
`*.likelihood` <-function(e1,e2){
theta.range = e2@theta_range
likelihood.func <- e1@func
prior.func <- e2@func
# normalise the pior
if(theta.range[1] != theta.range[2]){
K = suppressWarnings(1 / integrate(f = prior.func, lower = theta.range[1], upper = theta.range[2])$value)
} else{
K = 1
}
marginal <- function(theta){suppressWarnings(likelihood.func(theta = theta) * (K * prior.func(theta = theta)))}
if(theta.range[1] != theta.range[2]){
alt.val <- suppressWarnings(integrate(marginal,theta.range[1],theta.range[2])$value)
} else {
alt.val <- marginal(theta.range[[1]])
}
alt.func <- marginal
data = list(
integral = alt.val,
marginal = marginal,
prior.normalising.constant = K)
#  new(Class = 'marginal',
#      data = data,
#      K = K,
#      lik = likelihood.func,
#      prior = prior.func,
#      theta.range = theta.range)
}
data_model * h1_model
data_model * h1_model
data_model * h1_model
prior(distribution = "point", min = 0, max = 20)
prior(distribution = "point")
# prior dispatch function
prior <- function(distribution, ...) {
parameters <- as.list(match.call(expand.dots = TRUE))
range <- parameters$range %||% c(-Inf, Inf) # nolint
# prior function needs parameters for
# distribution - normal, student_t, beta, cauchy, uniform, point
# parameters - parameters for the distributions
# range_of_support :: for one tailed etc
distribution <- paste0(parameters$distribution %||%
"uniform", ".prior")
lik_fun <- purrr::partial(
.f = rlang::as_function(distribution),
range = range, ...
)
return(lik_fun())
}
uniform.prior <- function(min, max, range) { # nolint
new(
Class = "prior",
theta_range = range,
func = eval(parse(
text =
(paste0(
"function(theta) dunif(x = theta, min = ",
min, ", max = ",
max, ")"
))
)),
type = "uniform",
parameters = list(min = min, max = max)
)
}
point.prior <- function() { # nolint
new(
Class = "prior",
theta_range = range,
func = eval(parse(
text =
(paste0(
"function(theta) ifelse(theta == 0, 1, 0)"
))
)),
type = "point",
parameter = list(point = 0)
)
}
prior(distribution = "point")
# prior dispatch function
prior <- function(distribution, ...) {
parameters <- as.list(match.call(expand.dots = TRUE))
range <- parameters$range %||% c(-Inf, Inf) # nolint
# prior function needs parameters for
# distribution - normal, student_t, beta, cauchy, uniform, point
# parameters - parameters for the distributions
# range_of_support :: for one tailed etc
distribution <- paste0(parameters$distribution %||%
"uniform", ".prior")
lik_fun <- purrr::partial(
.f = rlang::as_function(distribution),
range = range, ...
)
return(lik_fun())
}
# functions for different prior distributions
normal.prior <- function() {} # nolint
student_t.prior <- function() {} # nolint
beta.prior <- function() {} # nolint
cauchy.prior <- function() {} # nolint
uniform.prior <- function(min, max, range) { # nolint
new(
Class = "prior",
theta_range = range,
func = eval(parse(
text =
(paste0(
"function(theta) dunif(x = theta, min = ",
min, ", max = ",
max, ")"
))
)),
type = "uniform",
parameters = list(min = min, max = max)
)
}
point.prior <- function(range) { # nolint
new(
Class = "prior",
theta_range = range,
func = eval(parse(
text =
(paste0(
"function(theta) ifelse(theta == 0, 1, 0)"
))
)),
type = "point",
parameter = list(point = 0)
)
}
prior(distribution = "point")
h1_model <- prior(distribution = "uniform", min = 0, max = 20)
h1_model
prior(distribution = "point")
point.prior <- function(range) { # nolint
new(
Class = "prior",
theta_range = range,
func = eval(parse(
text =
(paste0(
"function(theta) ifelse(theta == 0, 1, 0)"
))
)),
type = "point",
parameters = list(point = 0)
)
}
prior(distribution = "point")
h0_model <- prior(distribution = "point")
h1_model <- prior(distribution = "uniform", min = 0, max = 20)
h1_model
h0_model <- prior(distribution = "point")
h0_model
library(bayesplay)
`*.likelihood` <-function(e1,e2){
theta.range = e2@theta_range
likelihood.func <- e1@func
prior.func <- e2@func
# normalise the pior
if(theta.range[1] != theta.range[2]){
K = suppressWarnings(1 / integrate(f = prior.func, lower = theta.range[1], upper = theta.range[2])$value)
} else{
K = 1
}
marginal <- function(theta){suppressWarnings(likelihood.func(theta = theta) * (K * prior.func(theta = theta)))}
if(theta.range[1] != theta.range[2]){
alt.val <- suppressWarnings(integrate(marginal,theta.range[1],theta.range[2])$value)
} else {
alt.val <- marginal(theta.range[[1]])
}
alt.func <- marginal
data = list(
integral = alt.val,
marginal = marginal,
prior.normalising.constant = K)
#  new(Class = 'marginal',
#      data = data,
#      K = K,
#      lik = likelihood.func,
#      prior = prior.func,
#      theta.range = theta.range)
}
library(bayesplay)
data_model * h1_model
h1 <- data_model * h1_model
m1 <- data_model * h1_model
m0 <- data_model * h0_model
h0_model
h0_model <- prior(distribution = "point", range = c(-1,1))
h0_model
m1 <- data_model * h1_model
m0 <- data_model * h0_model
m0
m1
h0_model
h0_model <- prior(distribution = "point")
e1 <- data_model
theta.range = h0_model$theta_range
likelihood.func <- data_model@func
theta.range = h0_model@theta_range
likelihood.func <- data_model@func
prior.func <- h0_model@func
if(theta.range[1] != theta.range[2]){
K = suppressWarnings(1 / integrate(f = prior.func, lower = theta.range[1], upper = theta.range[2])$value)
} else{
K = 1
}
marginal <- function(theta){suppressWarnings(likelihood.func(theta = theta) * (K * prior.func(theta = theta)))}
if(theta.range[1] != theta.range[2]){
alt.val <- suppressWarnings(integrate(marginal,theta.range[1],theta.range[2])$value)
} else {
alt.val <- marginal(theta.range[[1]])
}
h0_model <- prior(distribution = "point", range = c(0,0))
m0 <- data_model * h0_model
m1
m1$integral
m1$integral / m0$integral
round(m1$integral / m0$integral,2)
point.prior <- function(range, point) { # nolint
new(
Class = "prior",
theta_range = c(point,point),
func = eval(parse(
text =
(paste0(
"function(theta) ifelse(theta == ",point,", 1, 0)"
))
)),
type = "point",
parameters = list(point = point)
)
}
point.prior <- function(range, point = 0) { # nolint
new(
Class = "prior",
theta_range = c(point,point),
func = eval(parse(
text =
(paste0(
"function(theta) ifelse(theta == ",point,", 1, 0)"
))
)),
type = "point",
parameters = list(point = point)
)
}
h0_model <- prior(distribution = "point")
h0_model
m1 <- data_model * h1_model
m0 <- data_model * h0_model
h0_model <- prior(distribution = "point", point = 1)
h0_model
h0_model <- prior(distribution = "point", point = 0)
h0_model
library(bayesplay)
`*.likelihood` <- bayesplay:::`*.likelihood`
library(bayesplay)
`*.likelihood` <- bayesplay:::`*.likelihood`
m1 <- data_model * h1_model
m1
m0 <- data_model * h0_model
m0
data_model
data_model@func()
data_model@func
m1
m1 / m2
m1 / m0
m1 <- data_model * h1_model
m1
m0 <- data_model * h0_model
m0
m1
m1  / m2
m1$integral / m0$integral
m1
m1$marginal()
m1$marginal(seq(-10,10,.01))
plot(m1$marginal(seq(-10,10,.01)))
plot(m1$marginal(seq(-100,100,.01)))
plot(m1$marginal(seq(-100,100,.001)))
plot(m0$marginal(seq(-100,100,.001)))
plot(m0$marginal(seq(-100,100,.001)))
m0
library(bayesplay)
bayesplay::`*.likelihood`()
bayesplay:::`*.likelihood`()
bayesplay:::`*.likelihood`
bayesplay::`*.likelihood`
h1_model
library(bayesplay)
library(bayesplay)
data_model
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>"
)
library(bayesplay)
md <- 5
se <- 10
data_model <- likelihood(distribution = "normal", center = md,  scale = se)
data_model
data_model$likelihood_type
data_model$parameters
h1_model <- prior(distribution = "uniform", min = 0, max = 20)
h1_model
h0_model <- prior(distribution = "point", point = 0)
h0_model
m1 <- data_model * h1_model
data_model
class(data_model)
class(h1_model)
library(bayesplay)
data_model * h1_model
data_model *.likelihood h1_model
data_model
`*`
`*` <- `*`
library(bayesplay)
.Primitive("*")
source('~/GitHub/r_packages/bayesplay/R/genericsish.r')
2 * 10
library(bayesplay)
m0 <- data_model * h0_model
library(bayesplay)
library(bayesplay)
library(bayesplay)
library(bayesplay)
.Primitive("*")
ggplot2::`%+%`
ggplot2:::`+.gg`
library(bayesplay)
library(bayesplay)
data_model
%*%
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>"
)
library(bayesplay)
md <- 5
se <- 10
data_model <- likelihood(distribution = "normal", center = md,  scale = se)
data_model
data_model$likelihood_type
data_model$parameters
h1_model <- prior(distribution = "uniform", min = 0, max = 20)
h1_model
h0_model <- prior(distribution = "point", point = 0)
h0_model
m1 <- data_model * h1_model
"*.numeric" <- .Primitive("*")
"*.likelihood" <- function(e1,e2){
theta.range = e2@theta_range
likelihood.func <- e1@func
prior.func <- e2@func
# normalise the pior
if(theta.range[1] != theta.range[2]){
K = suppressWarnings(1 / integrate(f = prior.func, lower = theta.range[1], upper = theta.range[2])$value)
} else{
K = 1
}
marginal <- function(theta){suppressWarnings(likelihood.func(theta = theta) * (K * prior.func(theta = theta)))}
if(theta.range[1] != theta.range[2]){
alt.val <- suppressWarnings(integrate(marginal,theta.range[1],theta.range[2])$value)
} else {
alt.val <- marginal(theta.range[[1]])
}
alt.func <- marginal
data = list(
integral = alt.val,
marginal = marginal,
prior.normalising.constant = K)
#  new(Class = 'marginal',
#      data = data,
#      K = K,
#      lik = likelihood.func,
#      prior = prior.func,
#      theta.range = theta.range)
}
m1 <- data_model * h1_model
m1
10 * 1
10 * 3
sum
*
`*`
.Primitive("*")
typeof(.Primitive("*"))
bayesplay::`*.likelihood`()
library(bayesplay)
m1 <- data_model * h1_model
library(bayesplay)
source('~/GitHub/r_packages/bayesplay/R/genericsish.r')
method('+')
methods('+')
methods('*')
class(data_model)
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>"
)
library(bayesplay)
md <- 5
se <- 10
data_model <- likelihood(distribution = "normal", center = md,  scale = se)
data_model
data_model$likelihood_type
data_model$parameters
h1_model <- prior(distribution = "uniform", min = 0, max = 20)
h1_model
h0_model <- prior(distribution = "point", point = 0)
h0_model
m1 <- data_model * h1_model
class(h0_model)
class(data_model)
library(bayesplay)
methods("*")
methods("*")
methods("+")
methods("*")
data_model
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>"
)
library(bayesplay)
md <- 5
se <- 10
data_model <- likelihood(distribution = "normal", center = md,  scale = se)
data_model
data_model$likelihood_type
data_model$parameters
h1_model <- prior(distribution = "uniform", min = 0, max = 20)
h1_model
h0_model <- prior(distribution = "point", point = 0)
h0_model
m1 <- data_model * h1_model
class(data_model)
class(data_model) <- "likelihood"
m1 <- data_model * h1_model
class(data_model)
h1_model
class(h1_model) <- "likelihood"
m1 <- data_model * h1_model
class(data_model) <- "bp"
class(h1_model) <- "bp"
library(bayesplay)
library(bayesplay)
class(data_model) <- "bp"
class(h1_model) <- "bp"
m1 <- data_model * h1_model
"*.bp" <- function(e1,e2){
theta.range = e2@theta_range
likelihood.func <- e1@func
prior.func <- e2@func
# normalise the pior
if(theta.range[1] != theta.range[2]){
K = suppressWarnings(1 / integrate(f = prior.func, lower = theta.range[1], upper = theta.range[2])$value)
} else{
K = 1
}
marginal <- function(theta){suppressWarnings(likelihood.func(theta = theta) * (K * prior.func(theta = theta)))}
if(theta.range[1] != theta.range[2]){
alt.val <- suppressWarnings(integrate(marginal,theta.range[1],theta.range[2])$value)
} else {
alt.val <- marginal(theta.range[[1]])
}
alt.func <- marginal
data = list(
integral = alt.val,
marginal = marginal,
prior.normalising.constant = K)
#  new(Class = 'marginal',
#      data = data,
#      K = K,
#      lik = likelihood.func,
#      prior = prior.func,
#      theta.range = theta.range)
}
m1 <- data_model * h1_model
m1
class(data_model)
library(bayesplay)
library(bayesplay)
md <- 5
se <- 10
data_model <- likelihood(distribution = "normal", center = md,  scale = se)
data_model
data_model$likelihood_type
data_model$parameters
h1_model <- prior(distribution = "uniform", min = 0, max = 20)
h1_model
h0_model <- prior(distribution = "point", point = 0)
h0_model
class(data_model) <- "bp"
class(h1_model) <- "bp"
m1 <- data_model * h1_model
library(bayesplay)
names(data_model)
names(h0_model)
h0_model
